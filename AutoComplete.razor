@typeparam TItem

<div class="autocomplete position-relative @(DarkMode ? "dark-mode" : "light-mode")"
     @onfocusout="HandleFocusOut"
     style="display:flex; flex-wrap:wrap; align-items:center; border:1px solid #ced4da; border-radius:.25rem; padding:.25rem; min-height:38px;">

    @foreach (var item in SelectedItemsInternal)
    {
        <span class="autocomplete-chip">
            @if (ChipTemplate is not null)
            {
                @ChipTemplate(item)
            }
            else
            {
                @ItemText(item)
            }
            <button type="button" class="btn-close" @onclick="() => RemoveItem(item)"></button>
        </span>
    }

    <input type="search"
           @ref="inputRef"
           @bind="typedWord"
           @bind:event="oninput"
           @bind:after="SearchItem"
           @onkeydown="HandleKeyDown"
           @onfocus="ShowAllItems"
           placeholder="@PlaceholderText"
           disabled="@IsDisabled"
           class="flex-grow-1 border-0"
           style="min-width:120px; outline:none;" />

    @if (isDropdownOpen)
    {
        <div class="autocomplete-dropdown position-absolute"
             style="width:100%; max-height:200px; overflow-y:auto; z-index:1000; top:100%; left:0; @(DarkMode ? "background-color:#2b2b2b;color:#d9dbdd;" : "background-color:white;")">
            @if (filteredItems.Any())
            {
                @for (int i = 0; i < filteredItems.Count; i++)
                {
                    var item = filteredItems[i];
                    <div class="px-3 py-2 cursor-pointer @(i == highlightedIndex ? "bg-primary text-white" : "")"
                         @onclick="() => SelectItem(item)">
                        @if (ItemTemplate is not null)
                        {
                            @ItemTemplate(item)
                        }
                        else
                        {
                            @ItemText(item)
                        }
                    </div>
                }
            }
            else
            {
                <div class="px-3 py-2 text-muted small">@EmptyMessage</div>
            }
        </div>
    }
</div>

@code {
    /// <summary>
    /// The list of all items available to select.
    /// </summary>
    [Parameter, EditorRequired]
    public List<TItem> AllItems { get; set; } = [];

    /// <summary>
    /// The list of items that are currently selected by the user.
    /// </summary>
    [Parameter]
    public List<TItem> SelectedItems { get; set; } = [];

    /// <summary>
    /// Event callback triggered whenever the selected items list changes.
    /// </summary>
    [Parameter]
    public EventCallback<List<TItem>> SelectedItemsChanged { get; set; }

    /// <summary>
    /// Function that defines how to display an item as text when no template is provided.
    /// This is particularly useful for complex objects, so you can specify which property
    /// or combination of properties should appear as the default text.
    /// </summary>
    [Parameter]
    public Func<TItem, string> ItemText { get; set; } = item => item?.ToString() ?? "";

    /// <summary>
    /// Placeholder text displayed in the input box.
    /// </summary>
    [Parameter]
    public string PlaceholderText { get; set; } = "Type to search...";

    /// <summary>
    /// Text to display when no matching items are found.
    /// </summary>
    [Parameter]
    public string EmptyMessage { get; set; } = "No record found...";

    /// <summary>
    /// Whether the autocomplete input should be disabled.
    /// </summary>
    [Parameter]
    public bool IsDisabled { get; set; }

    /// <summary>
    /// Whether to apply dark mode styling.
    /// </summary>
    [Parameter]
    public bool DarkMode { get; set; }

    /// <summary>
    /// Optional template for rendering each item in the dropdown.
    /// </summary>
    [Parameter]
    public RenderFragment<TItem>? ItemTemplate { get; set; }

    /// <summary>
    /// Optional template for rendering each selected item as a chip.
    /// </summary>
    [Parameter]
    public RenderFragment<TItem>? ChipTemplate { get; set; }

    private string typedWord = string.Empty;
    private List<TItem> filteredItems = [];
    private List<TItem> copyAllItems = [];
    private List<TItem> SelectedItemsInternal = [];
    private ElementReference inputRef = default!;
    private bool isDropdownOpen;
    private int highlightedIndex = -1;

    protected override async Task OnInitializedAsync()
    {
        copyAllItems = AllItems.ToList();
        SelectedItemsInternal = SelectedItems.ToList();
        await SelectedItemsChanged.InvokeAsync(SelectedItemsInternal);
    }

    private void SearchItem()
    {
        if (!string.IsNullOrEmpty(typedWord))
        {
            filteredItems = copyAllItems
                .Where(i => ItemText(i).Contains(typedWord, StringComparison.OrdinalIgnoreCase)
                         && !SelectedItemsInternal.Contains(i))
                .ToList();
            highlightedIndex = filteredItems.Any() ? 0 : -1;
            isDropdownOpen = true;
        }
        else
        {
            filteredItems.Clear();
            highlightedIndex = -1;
            isDropdownOpen = false;
        }
    }

    private async Task SelectItem(TItem item)
    {
        if (!SelectedItemsInternal.Contains(item))
        {
            SelectedItemsInternal.Add(item);
            typedWord = string.Empty;
            filteredItems.Clear();
            highlightedIndex = -1;
            await SelectedItemsChanged.InvokeAsync(SelectedItemsInternal);
            await inputRef.FocusAsync();
        }
    }

    private void ShowAllItems()
    {
        filteredItems = copyAllItems
            .Where(i => !SelectedItemsInternal.Contains(i))
            .ToList();
        highlightedIndex = filteredItems.Any() ? 0 : -1;
        isDropdownOpen = filteredItems.Any();
    }

    private async Task RemoveItem(TItem item)
    {
        if (SelectedItemsInternal.Contains(item))
        {
            SelectedItemsInternal.Remove(item);
            await SelectedItemsChanged.InvokeAsync(SelectedItemsInternal);
            SearchItem();
            await inputRef.FocusAsync();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Backspace" && string.IsNullOrEmpty(typedWord) && SelectedItemsInternal.Any())
        {
            var lastItem = SelectedItemsInternal.Last();
            SelectedItemsInternal.Remove(lastItem);
            await SelectedItemsChanged.InvokeAsync(SelectedItemsInternal);
            SearchItem();
            return;
        }

        if (e.Key == "Escape")
        {
            filteredItems.Clear();
            highlightedIndex = -1;
            isDropdownOpen = false;
            return;
        }

        if (!isDropdownOpen) return;

        switch (e.Key)
        {
            case "ArrowDown":
                if (filteredItems.Any())
                {
                    highlightedIndex = (highlightedIndex + 1) % filteredItems.Count;
                    StateHasChanged();
                }
                break;
            case "ArrowUp":
                if (filteredItems.Any())
                {
                    highlightedIndex = (highlightedIndex - 1 + filteredItems.Count) % filteredItems.Count;
                    StateHasChanged();
                }
                break;
            case "Enter":
                if (highlightedIndex >= 0 && highlightedIndex < filteredItems.Count)
                {
                    await SelectItem(filteredItems[highlightedIndex]);
                }
                break;
        }
    }

    private async Task HandleFocusOut(FocusEventArgs e)
    {
        await Task.Delay(150);
        isDropdownOpen = false;
    }
}
